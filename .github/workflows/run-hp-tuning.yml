name: Deploy to Minikube

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  minikube-test:
    runs-on:
      - ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3

    - name: Create local bucket directory
      run: |
        mkdir -p ${{ github.workspace }}/local_bucket

    - name: Install Minikube
      run: |
        curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
        sudo install minikube-linux-amd64 /usr/local/bin/minikube
        minikube start --driver=docker --mount=true --mount-string="${{ github.workspace }}/local_bucket:/mounted-workspace"
    - name: Install Katib
      run: |
        kubectl apply -k "github.com/kubeflow/katib.git/manifests/v1beta1/installs/katib-standalone?ref=v0.17.0"
        kubectl wait --for=condition=available -n kubeflow deployment/katib-controller --timeout=1m

    - name: Install Model Registry
      run: |
        kubectl apply -k "https://github.com/kubeflow/model-registry/manifests/kustomize/overlays/db?ref=v0.2.3-alpha"
        kubectl wait --for=condition=available -n kubeflow deployment/model-registry-deployment --timeout=2m

    - name: Configure Storage
      run: |
        kubectl apply -f manifests/create_pv.yaml
        kubectl apply -f manifests/create_pvc.yaml

    - name: Build Training Container
      run: |
        # Configure docker to use minikube's Docker daemon
        eval $(minikube docker-env)
        # Build the training container
        docker build -t train-model:latest -f docker/Dockerfile.train-model .

    - name: Run Training Job
      run: |
        kubectl create -f manifests/train-model.yaml
        sleep 200
        echo $(kubectl get experiments train-model -n kubeflow -o jsonpath='{.status.conditions[?(@.type=="Running")].status}')
        kubectl get events -n kubeflow

    - name: List Files
      run: |
        ls -la ${{ github.workspace }}/local_bucket

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install model-registry dependency
      run: |
        pip install "model-registry==0.2.9"

    - name: Run update script
      run: |
        python scripts/update_deploy_details.py

    - name: Compare models and extract URI
      id: model-check
      run: |
        # Extract model details
        NEW_MODEL=$(jq -r '.new_model' deploy_details.json)
        PROD_MODEL=$(jq -r '.prod_model' deploy_details.json)
        
        # Compare models
        if [ "$NEW_MODEL" == "$PROD_MODEL" ]; then
          echo "Models are identical. No action needed."
          echo "needs_deployment=false" >> $GITHUB_OUTPUT
        else
          echo "Models are different. Deployment needed."
          NEW_MODEL_URI=$(jq -r '.new_model.uri' deploy_details.json)
          echo "needs_deployment=true" >> $GITHUB_OUTPUT
          echo "model_uri=$NEW_MODEL_URI" >> $GITHUB_OUTPUT
        fi

    - name: Deploy Model Service
      if: steps.model-check.outputs.needs_deployment == 'true'
      run: |
        # Stop minikube to free up Docker daemon
        eval $(minikube docker-env -u)
        
        # Build the service container using host Docker
        docker build -t boston-housing-api -f docker/Dockerfile.app .
        
        # Deploy the service on host machine
        docker run -d -p 8005:8005 --name boston-housing-service boston-housing-api
        
        # Wait for service to be ready
        sleep 10
        
        # Test service health
        response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8005/health)
        if [ "$response" != "200" ]; then
          echo "Service health check failed with status: $response"
          exit 1
        else
          echo "Service deployed and healthy"
        fi

    - name: Cleanup
      if: always()
      run: |
        minikube delete